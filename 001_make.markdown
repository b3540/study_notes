# C言語のビルドについて
2015/02/19 Thu

# 目的
C言語の文法を理解することと、C言語のビルドを理解することは大分異なる。
今回は、C言語のビルドの仕組みを理解することに全力を注ぐ。

オマケとして、autotoolsの使い方を解説し、憧れの`configure`を理解する。

# 言葉の定義

まずは、ビルドとコンパイルの定義を明確にする。

## ビルド
> ソースコードのコンパイルやライブラリのリンクなどを行い、最終的な実行可能ファイルを作成すること。
> また、そのような作業によって生成されたソフトウェアの版。

IT用語辞典 - e-Words [ビルド] より

## コンパイル

> プログラミング言語で書かれたコンピュータプログラム(ソースコード)を解析し、
> コンピュータが直接実行可能な形式のプログラム(オブジェクトコード)に
> 変換すること。そのためのソフトウェアをコンパイラ(compiler)という。

IT用語辞典 - e-Words [コンパイル] より

## 両者の違い
ビルド >> コンパイル という認識で良い。
沢山のファイルを`コンパイル`して、リンクして、実行可能ファイルを作成する一連の流れが`ビルド`

# ツール類

## コンパイラ
1. gcc
2. glibc
3. llvm-gcc

細かいことは良く分かってないです。
方言というほどには、違わないようです。最適化の方法とかが違うとか、うんぬん・・・。

初心者レベルは、とにかく`gcc`使っておけば良いと理解しておきます。

## ビルドツール
1. make
2. cmake
3. scons
4. gyp

っていうか、これについても2番以降はよく分からない。

初心者レベルは、とにかく`make`でビルドすると理解しておきます。

後述のautotoolsも最終的には、`make`を使います。


# コンパイル
例)

```
$ gcc -o hello hello.c
```

```hello.c
#include <stdio.h>

int main(){
    printf("Hello World\n");
    exit;
}
```

`gcc`コマンドを使って、C言語のソースコードをオブジェクトファイルに変換します。
main関数が含まれ、かつリンクが解決されている場合は、その時点で実行可能ファイルです。

この場合は、ビルド ≒ コンパイル

## コンパイルオプション
+ o
その名前で実行ファイルを作る。指定しない場合は、`a.out`という名前でコンパイルされる。
+ c
リンクを行わない。preprocess, complile, assembleのみ行う。

# リンク
大きく２種類ある。

## 動的リンク
実行可能ファイルそのものには、含まれていないコードを実行時に読み込むことを動的リンクといいます。


```
#include <stdio.h>
```
このC言語ファイルのお約束の一文は、共有ライブラリの読み込みを表しています。
実行時に共有ライブラリを読み込んで、その内容を利用するという意味です。

特定の実行ファイルについて、どの共有ライブラリがリンクされているのかを調べるには、OS毎に下記のコマンドで行います。
+ Linux系OS
`ldd`
+ Mac OSX
`otool -L`
+ Windows
分かんない・・・

### 実技
先ほど作成した`hello`コマンドの共有ライブラリを調べます。

```
otool -L hello
```

Macだと`dylib`, linuxだと`.so`, Windowsだと `dll` が動的リンクされてます。

## 静的リンク

複数のCのソース・ファイルをコンパイル時にまとめて、一つの実行可能ファイルを作るような場合は
実行可能ファイルにそれぞれのソースファイルのコンパイルされた内容が含まれ形になります。 これを静的リンクといいます。

プログラムに必要なオブジェクトファイルを静的に結合して、実行可能ファイルを生成します。


### 実技

```src1.c
#include <stdio.h>

int add(int x, int y);

int main (){
    int z = add(7, 5);
    printf("result is %d\n", z);
    return 1;
}
```


```src2.c
#include <stdio.h>

int add(int x, int y){
    return x + y ;
}
```

コンパイルとリンク

```
$ gcc -c src1.c
$ gcc -c src2.c
$ gcc -o add src1.o src2.o
```

## コンパイルに伴う色々

### ヘッダーファイル探索

`gcc`は以下のディレクトリの順番で、 `#include`で指定したヘッダーファイルを検索する。 
```
/usr/local/include
libdir/gcc/target/version/include
/usr/target/include
/usr/include
```

`-I`オプションは、ヘッダーファイルの検索先ディレクトリを上の先頭に追加できる。

### 共有ライブラリ探索

`include`されたヘッダーファイルの実体は、共有ライブラリモジュールに入っている。
その共有ライブラリモジュールの探索先は・・・、マニュアル内に見つけることが出来ませんでした・・・。m(_ _)m

一つ言えることは、`/usr/lib`とかを探索しているということと、次のオプションで探索先の先頭にディレクトリを追加できます。

`-L`オプションで、共有ライブラリの探索先を追加できます。


### 余談 `-L`オプションが必要になった話

`readline`というライブラリを使うソースコードを書いて、`gcc`でコンパイルしたが、どうしても上手く動かない。
原因は、Macの`readline`が`editline`という別物のシンボリックリンクだったためです。

別途`brew`でインストールした`readline`があったので、`-L`オプションでその`readeline`ライブラリを指定することで、
正常動作する実行可能ファイルの生成に成功しました。


# ビルド

ソースコードが増えてきて、複雑さが増してくると、実行可能ファイルの生成も非常に大変になります。
それぞれのCのソースをオブジェクトファイルにコンパイルして、リンクして・・・。非常にしんどいです。

しんどいけど機械的な作業は自動化するのが一番・・・というわけでmakeが誕生しました。

C言語の登場が1972年、makeが登場したのが1978年 makeは僕と同級生。

さっきの例もしんどいのでmakeにまかせてしまいましょう。

makeは、デフォルトでmakeコマンドが実行されたディレクトリ配下のMakefileというファイルに書かれている内容を読み込んで実行します。

```
all: clean src1.o src2.o
    gcc -o add src1.o src2.o

src1.o:
    gcc -c src1.c

src2.o:
    gcc -c src2.c

clean:
    rm -f *.o
```

１つだけ覚えておくべき`make`の鉄則があります。それは「字下げはタブ」です。
これを守らないと、`make`は実行できません。

makeは、*.oファイルの更新を感知して、再コンパイルを行います。
なので、実行可能ファイルを更新する場合は*.oファイルを削除する必要があります。

Makefile内では変数も扱えます。`${CC}`とかやると先頭でセットした`CC`という値を参照できます。

makeはとてもシンプルです。Makefileに書かれている指示を忠実に再現します。
ただし、makeは動的要素に弱いです。たとえば、環境の違いによって、共有ライブラリを見つけられない場合や、依存するライブラリのバージョンをチェックしたい場合
makeにそれらのチェックコマンドを書くのは大変です。(シェルっぽい記述ができるのでやろうと思えばやれると思うけど・・・)

そこで登場するのがAutotoolsです。


# Autotools

`autoconf`, `automake`, `libtools`の３つから成り立っている。

すでに殆ど皆さんは、これの恩恵にあずかっているはず。

```
$ ./configure
$ make
$ make install 
```

これは、`autotools`を使うことで簡単?に作成することが出来ます。

Autotoolsの情報は、色んな場所に四散していて、本来単純なツールなはずが、わかりにくくなっています。
Wikipediaの記述が結局は、一番分かりやすかったす。


+ autoconf
configure.in または configure.ac というファイルを入力として、 configureを生成するツール。
+ automake
Makefile.amを入力として、Makefile.inを生成するツール。
+ libtool
環境依存をなるべく避けたライブラリの作成とかに使うツールらしい。
詳細は調べてない。まあ生きるのに支障はない。





## autoconfって何やるの？
autoconfは、 configureを生成する。

環境調査とかするコードを書き越える。M4という言語です。
身構える必要なし、単純なスクリプト言語です。

## automakeって何やるの？
automakeは、Makefile.inを生成する。

configureが利用する。Makefile.inを生成してくれます。
じつは、automakeを使わなくてもMakefile.inを自前で作れば、それでも大丈夫。

## configureコマンドは何やるの？
configureコマンドを実行すると、Makefile.inを雛形にして、Makefileを出力する。


## autotoolsを使うことの利点 

しきたりに従って、`configure.ac`と`Makefile.am`を作成すれば
業界標準に近い`configure` `make` `make install`になります。

# autotoolsの実技 

ここで、一つ言っておきますが、手順を一つでも逆にしたりすると、途端に動かなくなります。
お気をつけ下さい・・・。

1. `configure.ac`の雛形を作成
```
autoscan 
```

2. `configure.scan`を改名
```
mv configure.scan configure.ac
```

3. `Makefile.am`を作成
```Makefile.am
bin_PROGRAMS=adder
adder_SOURCES=src1.c src2.c
```

4. `automake`を利用することを`configure.ac`へ追記
```configure.ac
AM_INIT_AUTOMAKE
AC_CONFIG_FILES([Makefile])
```

5. `automake`に必要なm4ライブラリを用意
```
aclocal
```

6. `automake`に必要なツールをインストール
```
automake -a -c 
```

7. `automake`で必須とされるファイルを準備
```
touch NEWS README AUTHORS ChangeLog
```

8. `Makefile.in`を作成
```
automake
```

9. `configure`を作成
```
autoconf
```

## 憧れの３連コマンド

```
$ ./configure
$ make
$ make install
```

ビルドの雛形を作ったら、一度コミットした上で、必要なライブラリチェックなどを足していきましょう。
一つ言えることは、あこがれを手に入れるための代償として、相当な数のビルド関連ファイルが作成されます。
必要最低限のものを残して、削除してしまいましょう。

## 覚えて帰って欲しいこと。

`autotools`は、古きよきビルドツール作成キットです。
ルールに従うことで、環境に依存しないビルドが用意できます。


