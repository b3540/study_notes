
# WebエンジニアのためのC言語入門ハンズオン #1

C言語は、習得までに非常に時間がかかる言語である。

> 「Cの罠と落とし穴」とか「Cのパズルブック」とか、「Cとその秘密」といったタイトルの本は山のようにあるのに、
>   他の言語では、その類の本がまったくないことに気づいたことあるかい？その理由をここで明らかにしておこう！

Peter van der Linden (1996). エキスパートCプログラミング -知られざるCの深層 アスキー出版局 23.

本ハンズオンは、すでに他の言語にて基本的なプログラミングの素養がある方を対象に、C言語というものの概要と  
それを独力で学び続けるために必要な、忘れにくい最低限のベース知識を習得することが目的です。


## 前提知識
Webエンジニアは大抵が下記いずれかの言語を習得していることを前提としています。

+ Ruby
+ PHP => 有利
+ Perl
+ Python
+ Java
+ Javascript


# 今日習得すること
+ 最低限の文法 
+ メモリ領域とアドレス空間
+ ポインター
+ 実習


# 最低限の文法 

## データ型
+ char
```
char moji = 'a';
```
char型は、シングルクォートで括ります。
+ int
```
int num = 5;
```
+ float
```
float num = 1.2f;
```
+ double
```
double num = 1.2345;
```

文字列型は無いです。文字列は`char`の配列です。  
文字列の終端はNull文字`\00`で区別されます。  

## 文字配列
```
char str[10] = "ABCDEFG";
char str[] = "ABCDEFG";
char *str = "ABCDEFG";  // これは定数になります。読み取り専用なので書き換え出来ません。
```

(余談) Nullバイト攻撃は、C言語の文字列配列の終端文字を狙った攻撃です。
変数を宣言するときは、データ型を指定する必要があります。

## ポインター関連の演算子
+ `*` 間接演算子
```
int *num;
```
+ `&` アドレス演算子
```
int a = 4;
int *b = &a;
```
ポインターについては、後でゆっくりやりますので、今は流して下さい。

## 文法
+ if else
+ for while
+ switch 
+ サブルーチン(function)
+ break continue
+ gotoと名札

goto以外は、まあ大体の言語でもあると思います。
プログラムの行末にはセミコロンが必要です。

## 共有ライブラリ
C言語それ自体は、最低限の文法とデータ型を持つのみです。  
そのままでは辛いので、共有ライブラリを`include`して、便利な関数群を使います。

有名なやつ
+ stdio.h  
標準入出力
+ stdlib.h  
メモリ確保とか
+ string.h  
文字列操作

## 演習問題1 
(1) 次のプログラムを写経して下さい。  
コピペしないで下さい。一文字一文字心を込めて打ち込んで下さい。

```
#include <stdio.h>

int main(){
    printf("Hello World\n");

    int a = 5;
    printf("a = %d\n", a);

    char ch = 'b';
    printf("ch = %c\n", ch);

    char str[10] = "abcdefghij";
    printf("str = %s\n", str);
}
```

ファイルは、`hello.c`という名前で保存してください。

(2) コンパイル
次のコマンドでコンパイルを行って下さい。

```
gcc -o hello hello.c
```

コンパイル後は、`hello`という名の実行ファイルができています。実行して見てください。  
終わった人は、下記のコマンドでもコンパイルを行って下さい。

```
gcc hello.c
```

何が出来たでしょうか？

(3) 下記のコマンドを実行して下さい。
+ Linux  
`ldd hello`
+ Mac  
`otool -L hello`

表示された物を見つめてみましょう。


# メモリ領域とアドレス空間
他の言語とC言語が異なる最大の物は、メモリ管理に対するエンジニアの関与が大きいということです。

下記の５つのメモリー空間を常に頭に思い浮かべる必要があります。  
自分が書いているコードが、**アドレス空間のどこに影響するのか？**を常に意識して下さい。

+ スタック
`main`関数がスタックの1番目に入ります。  
以降の関数は、`main`関数から呼び出されると、その上に積み上がっていくイメージです。  
実行が終わった関数は、スタックから取り除かれます。  
StackOverFlowとは、スタックが積み上がりすぎて用意したアドレス空間の範囲外まで達するエラーです。  
再帰呼び出しで無限ループさせると、発生させることが出来ます。
+ ヒープ  
ヒープは、スタックに関係なく、全ての関数からアクセス可能なメモリ空間です。  
`malloc`という関数で確保されるのはヒープ領域です。
ヒープに確保した領域は、明示的に解放するか、プログラムが終了するまで、確保され続けます。
いわゆるメモリリークは、ここで発生します。  
+ グローバル
関数外で宣言された変数は、ここに格納されます。グローバル空間です。  
つまり、あまり不用意に使うと、大変なことになります。
+ 定数  
文字列リテラルや、constキーワードで宣言された読み取り専用の変数です。  
ここに格納された変数は、書き換えが出来ません。
+ コード
ソースコードとかが読み込まれている空間です。

C言語を実装する時に、最も多く発生するエラーは、`Segmentation Fault`です。  
上記のアドレス空間は、それぞれがセグメントと呼ばれます。  

`Segmentation Fault`とは、実行中のプログラムが権限の無いアドレス空間・メモリ領域に触れようとしたことを指します。  

[メモリ領域の図]


## 演習問題2 
(1) 次のプログラムを写経して下さい。  
コピペしないで下さい。一文字一文字心を込めて打ち込んで下さい。
```
```

(2) それぞれの変数が、メモリ領域のどこに存在するのか考えて下さい。

## 思考練習
下記のPHPのコードで、同様に考えてみましょう。

```
<?php

class Animal {

    function createDog(){
        return new Dog();  //Dogクラスのインスタンスの参照を返す。
    }

}

function main(){
    $animal = new Animal();

    $dog = $animal->createDog();

    $dog->cry();
}

```

モダンなプログラミング言語は、Garbage Collectionという機能で、メモリ領域に保持された領域を解放します。  
もうお分かりになると思いますが、Garbage Collectionが解放を行うのは、メモリ領域の中の【○○○○】です。

# ポインタ
C言語において、ポインタとはメモリアドレスを表現するものです。

C言語では、全ての引数は値渡しです。  
そのため、それ以外のデータをやり取りしたい時は、メモリアドレスでやり取りします。

ポインタを理解する時に、鍵になるのは下記の２つです。

1. ポインタの概念  
すでに、高級言語で参照を使ったプログラムを書いているので、比較的すんなりと受け入れることができると思います。
2. ポインタのソースコード上での表現
C言語の書き方の問題です。慣れの問題とも言えます。


## 引数の型
`void add(int *a)`  
`void add(int* a)`
どちらでも、同じ結果が返りますが、変数名に`*`を寄せる前者を使ってください。

覚え方はこうです。  
「`*`演算子を適用すると、intが返ってくるような変数である`a`」

## 戻り値の型
`int *add(){}`
`int* add(){}`
どちらでも、同じ動作となりますが、意識的にデータ型から`*`を離して下さい。  

覚え方は上と同じです。
「`*`演算子を適用すると、intが返ってくるような戻り値を持つ関数add」です。

## ポインターの宣言
例として`int`型のポインターを宣言する。
```
int *a;

a = 4;  //これは出来ない。aはポインター
*a = 4; //これはOK。aに*演算子を適用してintの値を参照している。

```

引数や戻り値の型指定のことを思い出して下さい。`*`演算子を適用すると、`int`型の値が戻ってくる変数`a`です。
ポインター変数の中身を見るには`*`演算子を適用する必要があります。

## ポインターの宣言2
これは、初心者キラーです。ポインターの宣言時は、`*`がついていても間接参照になりません。
```
int *a = 4;  //一見出来そうだけど出来ない。
// 下記と同じ意味になってしまう。
// int *a;  
// a = 4;   => ポインタ変数にアドレスじゃない値を入れようとしている。

int b = 5;
int *a = &b;  //これは出来る

```
宣言時の代入は、その後の代入とは少し挙動が異なります。

## 演習問題1
(1) 下記のソースコードはポインターを使った簡単な演算を行っています。  
ちゃんと動作するプログラムです。写経してコンパイルして実行して下さい。

```
#include <stdio.h>

void add(int *a){
    *a = *a + 3;
}

int main(){
    int a = 1;
    add(&a);
    printf("a = %d\n", a);
}
```

(2) ソースコードの下記の記述は、それぞれ何を意味するでしょうか？

1. `add`関数の引数`int * a`
2. `add`関数内の` * a`の記述
3. `main`関数において、`add`関数を呼び出す時の引数`&a`とはなんでしょうか？

大事なことなので、２度言います。  
ポインターにおいて、最も重要なことは、**概念**だけでなく、**書き方**を正確に覚えるということです。

非常に残念なことではありますが、伝統的なC言語プログラミングの書き方は副作用のある書き方が多いです。
ポインターを相手関数に渡して、値をセットさせたりするので、値の変化を追うことが非常に難しいです。

## 演習問題2 
(1) 下記のプログラムは、文字列のポインターを関数に渡して、値をセットさせるプログラムです。  
上手く動くと思ったら、動きません。何故でしょう？

```
#include <stdio.h>

void setTitle(char * title){
    *title = "C Study";
}

int main(){
    char title[100];
    setTitle(&title);
    
    printf("title is %s\n", title);
}
```

### 重要なポイント
+ 文字列リテラルの使い所  
文字列リテラルをそのまま変数に代入できるのは、宣言時のみです。  
僕らが使っている高級言語のように、カジュアルに代入出来ません。
+ 配列は、ポインターのように振る舞います。  
intの時は、&を付けましたが、引数に文字配列のポインターが求められる時は、&を付けずに指定します。  
でも、配列は厳密にはポインターではないのです。（そんなの、今覚えなくていいです）
+ 文字列に何らかの操作を行う時は、string.hを使いましょう  
今回は、strcpyという関数を使って、`title`配列に値をコピーします。


## 演習問題3
(1) 副作用のあるソースコードは嫌なものです。そこで先のプログラムを修正して、文字列配列のポインターを戻すようにしてみました。  
このプログラムは、コンパイル出来ますが、タイトル「C Study」が表示できません。何故でしょう？

```
#include <stdio.h>
#include <string.h>

char * getTitle(){
    char title[10] = "C Study";
    return title;
}

int main(){
    char * title = getTitle();
    printf("title is %s\n", title);
}
```

# 参考図書
hanhan1978が学習に用いた本達です。良書厳選。

+ プログラミング言語C
+ Head First C
+ 詳解ポインター
+ エキスパートCプログラミング―知られざるCの深層

