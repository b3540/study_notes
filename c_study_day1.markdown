
# WebエンジニアのためのC言語入門ハンズオン #1

C言語は、習得までに非常に時間がかかる言語である。

> 「Cの罠と落とし穴」とか「Cのパズルブック」とか、「Cとその秘密」といったタイトルの本は山のようにあるのに、
>   他の言語では、その類の本がまったくないことに気づいたことあるかい？その理由をここで明らかにしておこう！

Peter van der Linden (1996). エキスパートCプログラミング -知られざるCの深層 アスキー出版局 23.

本ハンズオンは、すでに他の言語にて基本的なプログラミングの素養がある方を対象に、C言語というものの概要と  
それを独力で学び続けるために必要な、忘れにくい最低限のベース知識を習得することが目的です。


## 前提知識
Webエンジニアは大抵が下記いずれかの言語を習得していることを前提としています。

+ Ruby
+ PHP => 有利
+ Perl
+ Python
+ Java
+ Javascript


# 今日習得すること
+ 最低限の文法 
+ メモリ領域とアドレス空間
+ ポインター
+ 実習


# 最低限の文法 

## データ型
+ char
```
char moji = 'a';
```
char型は、シングルクォートで括ります。
+ int
```
int num = 5;
```
+ float
```
float num = 1.2f;
```
+ double
```
double num = 1.2345;
```

文字列型は無いです。文字列は`char`の配列です。  
文字列の終端はNull文字`\00`で区別されます。  

## 文字配列
```
char str[10] = "ABCDEFG";
char str[] = "ABCDEFG";
char *str = "ABCDEFG";  // これは定数になります。読み取り専用なので書き換え出来ません。
```

(余談) Nullバイト攻撃は、C言語の文字列配列の終端文字を狙った攻撃です。
変数を宣言するときは、データ型を指定する必要があります。

## ポインター関連の演算子
+ `*` 間接演算子
```
int *num;
```
+ `&` アドレス演算子
```
int a = 4;
int *b = &a;
```
ポインターについては、後でゆっくりやりますので、今は流して下さい。

## 文法
+ if else
+ for while
+ switch 
+ サブルーチン(function)
+ break continue
+ gotoと名札

goto以外は、まあ大体の言語でもあると思います。
プログラムの行末にはセミコロンが必要です。

## 共有ライブラリ
C言語それ自体は、最低限の文法とデータ型を持つのみです。  
そのままでは辛いので、共有ライブラリを`include`して、便利な関数群を使います。

有名なやつ
+ stdio.h  
標準入出力
+ stdlib.h  
メモリ確保とか
+ string.h  
文字列操作

## 演習問題1 
(1) 次のプログラムを写経して下さい。  
コピペしないで下さい。一文字一文字心を込めて打ち込んで下さい。

```
#include <stdio.h>

int main(){
    printf("Hello World\n");

    int a = 5;
    printf("a = %d\n", a);

    char ch = 'b';
    printf("ch = %c\n", ch);

    char str[10] = "abcdefghi";
    printf("str = %s\n", str);
}
```

ファイルは、`hello.c`という名前で保存してください。

(2) コンパイル
次のコマンドでコンパイルを行って下さい。

```
gcc -o hello hello.c
```

コンパイル後は、`hello`という名の実行ファイルができています。実行して見てください。  
終わった人は、下記のコマンドでもコンパイルを行って下さい。

```
gcc hello.c
```

実行可能ファイルは、何というファイル名で出来たでしょうか？

(3) 下記のコマンドを実行して下さい。
+ Linux  
`ldd hello`
+ Mac  
`otool -L hello`

表示された物は、動的リンク(実行時に読み込まれる)された共有ライブラリです。
本プログラムで利用している共有ライブラリは何でしょうか？


# メモリ領域とアドレス空間
他の言語とC言語が異なる最大の物は、メモリ管理に対するエンジニアの関与が大きいということです。

下記の５つのメモリー空間を常に頭に思い浮かべる必要があります。  
自分が書いているコードが、**アドレス空間のどこに影響するのか？**を常に意識して下さい。

+ スタック  
`main`関数がスタックの1番目に入ります。  
以降の関数は、`main`関数から呼び出されると、その上に積み上がっていくイメージです。  
実行が終わった関数は、スタックから取り除かれます。  
StackOverFlowとは、スタックが積み上がりすぎて用意したアドレス空間の範囲外まで達するエラーです。  
再帰呼び出しで無限ループさせると、発生させることが出来ます。
+ ヒープ  
ヒープは、スタックに関係なく、全ての関数からアクセス可能なメモリ空間です。  
`malloc`という関数で確保されるのはヒープ領域です。
ヒープに確保した領域は、明示的に解放するか、プログラムが終了するまで、確保され続けます。
いわゆるメモリリークは、ここで発生します。  
+ グローバル  
関数外で宣言された変数は、ここに格納されます。グローバル空間です。  
つまり、あまり不用意に使うと、大変なことになります。
+ 定数  
文字列リテラルや、constキーワードで宣言された読み取り専用の変数です。  
ここに格納された変数は、書き換えが出来ません。
+ コード  
ソースコードとかが読み込まれている空間です。

仮想アドレス空間の模式図↓です。

![仮想アドレス空間](https://github.com/hanhan1978/study_notes/blob/master/memory.png)

C言語を実装する時に、最も多く発生するエラーは、`Segmentation Fault`です。  
上記のアドレス空間は、それぞれがセグメントと呼ばれます。  

`Segmentation Fault`とは、実行中のプログラムが権限の無いアドレス空間・メモリ領域に触れようとしたことを指します。  


## 演習問題2 
(1) 次のプログラムを写経して下さい。  
コピペしないで下さい。一文字一文字心を込めて打ち込んで下さい。
```
#include <stdio.h>
#include <stdlib.h>


int glob1 = 123;
int glob2;

int main(){

    static int st1 = 123;
    static int st2;
    int local = 0;

    static char static_array[1024];
    char local_array[1024];
    char * dynamic_array;

    dynamic_array = (char *)malloc(1024);

    printf("----------- VAL -----------\n");
    printf("glob1   =>  %p\n", &glob1);
    printf("glob2   =>  %p\n", &glob2);
    printf("st1     =>  %p\n", &st1);
    printf("st2     =>  %p\n", &st2);
    printf("local   =>  %p\n", &local);
    printf("----------- ARR -----------\n");
    printf("static  =>  %p\n", static_array);
    printf("local   =>  %p\n", local_array);
    printf("dynamic =>  %p\n", dynamic_array);
    printf("----------- FUNC ----------\n");
    printf("main    =>  %p\n", main);
    printf("printf  =>  %p\n", printf);
}
```

書き終えたら、address_check.cという名前で保存して下さい。
先と同じ要領で、address_checkと言う名前の実行可能ファイルを作成して下さい。

(2) それぞれの変数が、メモリ領域のどこに存在するのか考えて下さい。

address_check関数を実行すると、それぞれの変数のメモリアドレスが出力されます。
仮想アドレス空間の図とメモリアドレスを比べてみて、変数がどのセグメントに含まれるかを考えて下さい。

※malloc関数は、ヒープに領域を確保する関数です。

## 思考練習
下記のPHPのコードで、同様に考えてみましょう。

```
<?php

class Animal {

    function createDog(){
        $a = 4;
        return new Dog($a);  //Dogクラスのインスタンスの参照を返す。
    }

}

function main(){
    $animal = new Animal();

    $dog = $animal->createDog();

    $dog->cry();
}

```

PHP, Ruby, Java等の最近の高級プログラミング言語は、関数がオブジェクトや文字列を参照で戻すことが出来ます。
つまり、上記でnewされたオブジェクトや、関数実行後に呼び元にセットされたインスタンスは、ヒープに確保された領域内のデータです。

しかし、ヒープの領域は明示的には解放されません。PHP, Ruby, Javaでは、C言語のfreeに相当する関数が提供されていません。
ヒープの領域が解放されないままで残ると、解放されないメモリが徐々に溜まっていきます。これをメモリリークと呼びます。

freeの代わりとして、これらの言語ではGarbage Collectionという機能が存在し、参照されなくなった変数やオブジェクトが含まれるヒープの領域を自動で解放します。


# ポインタ
C言語において、ポインタとはメモリアドレスを表現するものです。

C言語では、全ての引数は値渡しです。  
そのため、それ以外のデータをやり取りしたい時は、メモリアドレスでやり取りします。

ポインタを理解する時に、鍵になるのは下記の２つです。

1. ポインタの概念  
すでに、高級言語で参照を使ったプログラムを書いているので、比較的すんなりと受け入れることができると思います。
2. ポインタのソースコード上での表現
C言語の書き方の問題です。慣れの問題とも言えます。


## 引数の型
`void add(int * a){}`  
`void add(int* a){}`  
`void add(int *a){}`  
この３つの書き方は、全て同じです。

間接参照演算子を左寄せ(データ型側にくっつける)のか、右寄せ(変数名側にくっつける)、中立(どちらにもくっつけない)は  
コーディング規約に依ります。右寄せが一般的のようです。


## 戻り値の型
`int * add(){}`  

同様にして、右寄せ・左寄せ・中立のどの書き方でも同じです。


## ポインタ変数の宣言
例として`int`型のポインターを宣言する。
```
int *a;

a = 4;  //これは出来ない。aはポインター
*a = 4; //これはOK。aに*演算子を適用してintの値を参照している。

```

`*`演算子を適用すると、`int`型の値が戻ってくる変数`a`とおぼえてください。
ポインタ変数の中身を見るには`*`演算子を適用する必要があります。

## ポインタ変数の宣言2
これは、初心者キラーです。ポインタ変数の宣言時は、`*`がついていても間接参照になりません。
```
int *a = 4;  //一見出来そうだけど出来ない。
// 下記と同じ意味になってしまう。
// int *a;  
// a = 4;   => ポインタ変数にアドレスじゃない値を入れようとしている。

int b = 5;
int *a = &b;  //これは出来る

```
宣言時の代入は、その後の代入とは少し挙動が異なります。

## 演習問題1
(1) 下記のソースコードはポインターを使った簡単な演算を行っています。  
ちゃんと動作するプログラムです。写経してコンパイルして実行して下さい。

```
#include <stdio.h>

void add(int *a){
    *a = *a + 3;
}

int main(){
    int a = 1;
    add(&a);
    printf("a = %d\n", a);
}
```

書き終わったら、poi.cという名前で保存して下さい。
poiという名前で実行可能ファイルを作成して、実行して下さい。4が出力されたら成功です。

(2) ソースコードの下記の記述は、それぞれ何を意味するでしょうか？

1. `add`関数の引数`int * a`
2. `add`関数内の` *a`の記述
3. `main`関数において、`add`関数を呼び出す時の引数`&a`とはなんでしょうか？

大事なことなので、２度言います。  
ポインターにおいて、最も重要なことは、**概念**だけでなく、**書き方**を正確に覚えるということです。


## 演習問題2 
(1) 下記のプログラムは、文字列のポインターを関数に渡して、値をセットさせるプログラムです。  
上手く動くと思ったら、動きません。何故でしょう？

```
#include <stdio.h>

void setTitle(char * title){
    char title2[] = "C Study";
    title = title2;
}

int main(){
    char title[100];
    setTitle(&title);
    
    printf("title is %s\n", title);
}
```

(2) プログラムを修正して、上手く動作するようにして下さい。

ヒント
1. `<string.h>`という共有ライブラリを追加でincludeする。
2. 配列のポインタに、文字をコピーする時は、`strcpy`関数を使います。

# 実習問題
## 実習1 ポインタ
main関数内で、2つの`int`型の変数x, yを宣言して下さい。初期値は0です。
引数に2つのintのポインタを受け取る関数、goNorthとgoEastを作って下さい。

goNorthが呼ばれた場合は、yに1を足して下さい。
goEastが呼ばれた場合は、xに1を足して下さい。

goNorthを4回、goEastを3回実行した後、最後に変数x, yの内容を出力して下さい。

答え

```
x = 3;
y = 4;
```

## 実習2 配列ポインタ

文字列`ABCDE`を格納する文字列の配列を定義して下さい。
配列のポインタを利用して、先頭文字から順番に、全て小文字にして下さい。

最後に配列内容を出力して、`abcde`になることを確認して下さい。

### ヒント
+ char 'A' に +32すると小文字になります。
+ 配列の先頭文字のアドレスは配列変数そのものです。
+ 先頭文字のアドレスに+1すると、配列の2つ目のアドレスです。

## 実習3
`pwd`コマンドを自作してみましょう。

カレントディレクトリを取得する関数は、`getcwd`関数です。
`getcwd`のマニュアルは、`man getcwd`でチェック出来ます。

マニュアルの内容に従って、カレントディレクトリ取得して、表示するコマンドを作って下さい。

# 参考図書
hanhan1978が学習に用いた本達です。良書厳選。

+ プログラミング言語C  
<img src="http://ecx.images-amazon.com/images/I/41W69WGATNL.jpg" width='200'>
+ Head First C  
<img src="http://www.oreilly.co.jp/books/images/picture_large978-4-87311-609-9.jpeg" width='200'>
+ 詳説Cポインタ  
<img src="http://www.oreilly.co.jp/books/images/picture_large978-4-87311-656-3.jpeg" width='200'>
+ エキスパートCプログラミング―知られざるCの深層  
<img src="http://ecx.images-amazon.com/images/I/31LMc%2BpC7iL._SY344_BO1,204,203,200_.jpg" width='200'>

